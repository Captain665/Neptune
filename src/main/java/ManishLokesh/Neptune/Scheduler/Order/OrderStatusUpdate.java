package ManishLokesh.Neptune.Scheduler.Order;import ManishLokesh.Neptune.EmailTrigger.SendSignupOTP;import ManishLokesh.Neptune.PushToIRCTC.OrderStatus;import ManishLokesh.Neptune.v2.Orders.Entity.Orders;import ManishLokesh.Neptune.v2.Orders.Repository.OrderRepository;import ManishLokesh.Neptune.v2.customer.Entity.Customer;import ManishLokesh.Neptune.v2.customer.Repository.CustLoginRepo;import com.fasterxml.jackson.databind.JsonNode;import com.fasterxml.jackson.databind.ObjectMapper;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import org.slf4j.Logger;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.*;import static java.util.concurrent.CompletableFuture.runAsync;import java.util.concurrent.CompletionStage;@Componentpublic class OrderStatusUpdate {    private final ObjectMapper objectMapper;    @Autowired    public OrderStatus orderStatus;    @Autowired    public OrderRepository orderRepository;    @Autowired    public CustLoginRepo custLoginRepo;    public SendSignupOTP sendSignupOTP = new SendSignupOTP();    private final Logger logger = LoggerFactory.getLogger("Auto-Status-Update.Scheduler");    @Autowired    public OrderStatusUpdate(ObjectMapper objectMapper) {        this.objectMapper = objectMapper;    }    @Scheduled(fixedDelay = 120000)    public void AutoStatusUpdate() {        try {            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");            String localDateTime = LocalDateTime.now().format(formatter);            LocalDateTime currentDate = LocalDateTime.parse(localDateTime, DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"));            List<String> ordersList = orderRepository.OrderStatus();            logger.info("Order list for auto status update {}", ordersList.toString());            for (Object order : ordersList) {                String[] parts = order.toString().split(",");                String currentStatus = parts[1];                LocalDateTime deliveryDate = LocalDateTime.parse(parts[2], DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"));                if (deliveryDate.minusMinutes(30).isBefore(currentDate) &&                        deliveryDate.minusMinutes(25).isAfter(currentDate)                ) {                    runAsync(() -> updateStatus(Long.valueOf(parts[0]), "ORDER_PREPARING"));                } else if (deliveryDate.minusMinutes(20).isBefore(currentDate)                        && deliveryDate.minusMinutes(15).isAfter(currentDate)                ) {                    runAsync(() -> updateStatus(Long.valueOf(parts[0]), "ORDER_PREPARED"));                } else if (deliveryDate.minusMinutes(10).isBefore(currentDate)                        && deliveryDate.minusMinutes(5).isAfter(currentDate)) {                    runAsync(() -> updateStatus(Long.valueOf(parts[0]),"ORDER_OUT_FOR_DELIVERY"));                } else if (deliveryDate.plusHours(1).isBefore(currentDate)) {                    runAsync(() -> updateStatus(Long.valueOf(parts[0]), "ORDER_DELIVERED"));                }            }        } catch (Exception e) {            String msg = e.getMessage();            logger.info("Exception msg {}", msg);        }    }    public void updateStatus(Long orderId, String statusMarking) {        try {            Map<String, Object> status = new HashMap<>();            status.put("status", statusMarking);            Optional<Orders> orders = orderRepository.findById(orderId);            Orders order1 = orders.get();            String response = orderStatus.StatusPushToIrctc(status, order1.getIrctcOrderId());            Customer customer = custLoginRepo.findByCustomerId(Long.parseLong(order1.getCustomerId()));            JsonNode jsonNode = objectMapper.readTree(response);            JsonNode resultObject = jsonNode.get("result");            JsonNode responseStatus = resultObject.get("status");            JsonNode message = jsonNode.get("message");            if (responseStatus != null && statusMarking.equals(responseStatus.asText())) {                String[] saveStatus = statusMarking.split("_");                order1.setStatus(saveStatus[1] == "OUT" ? "OUT_OF_DELIVERY" : saveStatus[1] );                orderRepository.save(order1);                sendSignupOTP.sendOTP(customer.getEmailId(),                        "Order Status",                        "Your order " + order1.getId() + " has been marked as " + order1.getStatus() + " enjoy your meal !"                );            }else{                boolean alreadyMarkedAs = message.asText().contains(statusMarking);                String[] saveStatus = statusMarking.split("_");                if(alreadyMarkedAs){                    order1.setStatus(saveStatus[1]);                    orderRepository.save(order1);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }}